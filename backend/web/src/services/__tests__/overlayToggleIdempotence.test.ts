/**\n * Property-based tests for overlay toggle idempotence\n * Feature: synchronized-video-mesh-playback, Property 6: Overlay Toggle Idempotence\n * Validates: Requirements 5.1, 5.2, 5.3\n */\n\nimport { describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport fc from 'fast-check';\nimport { OverlayToggleService } from '../overlayToggleService';\n\n// Arbitraries for property-based testing\nconst sceneIdArbitrary = fc.string({ minLength: 1, maxLength: 50 });\nconst frameIndexArbitrary = fc.integer({ min: 0, max: 1000 });\n\ndescribe('Overlay Toggle Idempotence', () => {\n  let overlayService: OverlayToggleService;\n\n  beforeEach(() => {\n    overlayService = new OverlayToggleService();\n  });\n\n  afterEach(() => {\n    overlayService.clear();\n  });\n\n  describe('Property 6: Overlay Toggle Idempotence', () => {\n    it('should return to original state after toggling on then off then on', () => {\n      fc.assert(\n        fc.property(sceneIdArbitrary, (sceneId) => {\n          // Initialize overlay\n          overlayService.initializeOverlay(sceneId, true);\n\n          // Get initial state\n          const initialState = overlayService.isOverlayEnabled(sceneId);\n\n          // Toggle on -> off -> on\n          overlayService.toggleOverlay(sceneId);\n          overlayService.toggleOverlay(sceneId);\n          overlayService.toggleOverlay(sceneId);\n\n          // Should return to initial state\n          const finalState = overlayService.isOverlayEnabled(sceneId);\n          expect(finalState).toBe(initialState);\n        }),\n        { numRuns: 50 }\n      );\n    });\n\n    it('should maintain frame index without interruption during toggle', () => {\n      fc.assert(\n        fc.property(sceneIdArbitrary, frameIndexArbitrary, (sceneId, frameIndex) => {\n          overlayService.initializeOverlay(sceneId, true);\n          overlayService.updateFrameIndex(sceneId, frameIndex);\n\n          // Get initial frame index\n          const initialFrameIndex = overlayService.getFrameIndex(sceneId);\n\n          // Toggle overlay multiple times\n          for (let i = 0; i < 5; i++) {\n            overlayService.toggleOverlay(sceneId);\n          }\n\n          // Frame index should remain unchanged\n          const finalFrameIndex = overlayService.getFrameIndex(sceneId);\n          expect(finalFrameIndex).toBe(initialFrameIndex);\n          expect(finalFrameIndex).toBe(frameIndex);\n        }),\n        { numRuns: 50 }\n      );\n    });\n\n    it('should display identical frame after toggle on-off-on without frame index change', () => {\n      fc.assert(\n        fc.property(sceneIdArbitrary, frameIndexArbitrary, (sceneId, frameIndex) => {\n          overlayService.initializeOverlay(sceneId, true);\n          overlayService.updateFrameIndex(sceneId, frameIndex);\n\n          // Get initial state\n          const initialState = overlayService.getToggleState(sceneId);\n\n          // Toggle on -> off -> on\n          overlayService.toggleOverlay(sceneId);\n          overlayService.toggleOverlay(sceneId);\n          overlayService.toggleOverlay(sceneId);\n\n          // Get final state\n          const finalState = overlayService.getToggleState(sceneId);\n\n          // States should be identical\n          expect(finalState.isOverlayEnabled).toBe(initialState.isOverlayEnabled);\n          expect(finalState.frameIndex).toBe(initialState.frameIndex);\n          expect(finalState.sceneId).toBe(initialState.sceneId);\n        }),\n        { numRuns: 50 }\n      );\n    });\n\n    it('should allow toggling during playback without frame index interruption', () => {\n      fc.assert(\n        fc.property(\n          fc.array(sceneIdArbitrary, { minLength: 2, maxLength: 5 }),\n          frameIndexArbitrary,\n          (sceneIds, initialFrame) => {\n            // Initialize multiple scenes\n            for (const sceneId of sceneIds) {\n              overlayService.initializeOverlay(sceneId, true);\n              overlayService.updateFrameIndex(sceneId, initialFrame);\n            }\n\n            // Simulate playback with toggles\n            for (let frame = initialFrame; frame < initialFrame + 10; frame++) {\n              // Update frame indices\n              for (const sceneId of sceneIds) {\n                overlayService.updateFrameIndex(sceneId, frame);\n              }\n\n              // Toggle some overlays\n              if (frame % 2 === 0) {\n                overlayService.toggleOverlay(sceneIds[0]);\n              }\n\n              // Verify frame indices are maintained\n              for (const sceneId of sceneIds) {\n                expect(overlayService.getFrameIndex(sceneId)).toBe(frame);\n              }\n            }\n          }\n        ),\n        { numRuns: 30 }\n      );\n    });\n\n    it('should maintain idempotence across multiple toggle cycles', () => {\n      fc.assert(\n        fc.property(sceneIdArbitrary, (sceneId) => {\n          overlayService.initializeOverlay(sceneId, true);\n          const initialState = overlayService.isOverlayEnabled(sceneId);\n\n          // Multiple toggle cycles\n          for (let cycle = 0; cycle < 5; cycle++) {\n            // Toggle on -> off -> on\n            overlayService.toggleOverlay(sceneId);\n            overlayService.toggleOverlay(sceneId);\n            overlayService.toggleOverlay(sceneId);\n\n            // Should return to initial state\n            const currentState = overlayService.isOverlayEnabled(sceneId);\n            expect(currentState).toBe(initialState);\n          }\n        }),\n        { numRuns: 30 }\n      );\n    });\n\n    it('should handle explicit set operations idempotently', () => {\n      fc.assert(\n        fc.property(sceneIdArbitrary, (sceneId) => {\n          overlayService.initializeOverlay(sceneId, true);\n\n          // Set to true multiple times\n          overlayService.setOverlayEnabled(sceneId, true);\n          overlayService.setOverlayEnabled(sceneId, true);\n          overlayService.setOverlayEnabled(sceneId, true);\n\n          expect(overlayService.isOverlayEnabled(sceneId)).toBe(true);\n\n          // Set to false multiple times\n          overlayService.setOverlayEnabled(sceneId, false);\n          overlayService.setOverlayEnabled(sceneId, false);\n          overlayService.setOverlayEnabled(sceneId, false);\n\n          expect(overlayService.isOverlayEnabled(sceneId)).toBe(false);\n        }),\n        { numRuns: 30 }\n      );\n    });\n\n    it('should notify callbacks correctly during toggle operations', () => {\n      fc.assert(\n        fc.property(sceneIdArbitrary, (sceneId) => {\n          overlayService.initializeOverlay(sceneId, true);\n\n          const callbackStates: boolean[] = [];\n\n          // Subscribe to toggle changes\n          overlayService.onOverlayToggle(sceneId, (isEnabled) => {\n            callbackStates.push(isEnabled);\n          });\n\n          // Toggle multiple times\n          overlayService.toggleOverlay(sceneId); // false\n          overlayService.toggleOverlay(sceneId); // true\n          overlayService.toggleOverlay(sceneId); // false\n\n          // Verify callback sequence\n          expect(callbackStates).toEqual([false, true, false]);\n        }),\n        { numRuns: 30 }\n      );\n    });\n  });\n});\n