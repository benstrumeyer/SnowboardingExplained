/**\n * Property-based tests for video-mesh frame correspondence\n * Feature: synchronized-video-mesh-playback, Property 4: Video-Mesh Frame Correspondence\n * Validates: Requirements 6.6, 7.1\n */\n\nimport { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';\nimport fc from 'fast-check';\nimport { FrameDataService, FrameData } from '../frameDataService';\n\n// Arbitraries for property-based testing\nconst videoIdArbitrary = fc.string({ minLength: 1, maxLength: 50 });\nconst frameIndexArbitrary = fc.integer({ min: 0, max: 1000 });\n\ndescribe('Video-Mesh Frame Correspondence', () => {\n  let frameDataService: FrameDataService;\n\n  beforeEach(() => {\n    frameDataService = new FrameDataService({\n      apiBaseUrl: 'http://localhost:3001',\n      cacheSize: 100\n    });\n\n    // Mock fetch\n    global.fetch = vi.fn();\n  });\n\n  afterEach(() => {\n    frameDataService.clearCache();\n    vi.clearAllMocks();\n  });\n\n  describe('Property 4: Video-Mesh Frame Correspondence', () => {\n    it('should return video frame that corresponds to mesh frame at same frameIndex', () => {\n      fc.assert(\n        fc.property(videoIdArbitrary, frameIndexArbitrary, async (videoId, frameIndex) => {\n          // Mock backend response\n          const mockFrameData: FrameData = {\n            videoId,\n            frameIndex,\n            timestamp: frameIndex * (1000 / 30),\n            originalFrame: 'base64data',\n            overlayFrame: 'base64overlay',\n            meshData: {\n              keypoints: [],\n              skeleton: { connections: [] }\n            }\n          };\n\n          (global.fetch as any).mockResolvedValueOnce({\n            ok: true,\n            headers: new Map([['content-encoding', 'identity']]),\n            json: async () => mockFrameData\n          });\n\n          // Get frame data\n          const frameData = await frameDataService.getFrame(videoId, frameIndex, {\n            includeOriginal: true,\n            includeOverlay: true,\n            includeMesh: true\n          });\n\n          // Verify correspondence\n          expect(frameData.frameIndex).toBe(frameIndex);\n          expect(frameData.videoId).toBe(videoId);\n\n          // If original frame is present, it should be for this frameIndex\n          if (frameData.originalFrame) {\n            expect(frameData.frameIndex).toBe(frameIndex);\n          }\n\n          // If overlay frame is present, it should be for this frameIndex\n          if (frameData.overlayFrame) {\n            expect(frameData.frameIndex).toBe(frameIndex);\n          }\n\n          // If mesh data is present, it should be for this frameIndex\n          if (frameData.meshData) {\n            expect(frameData.frameIndex).toBe(frameIndex);\n          }\n        }),\n        { numRuns: 50 }\n      );\n    });\n\n    it('should maintain frame correspondence across multiple scenes', () => {\n      fc.assert(\n        fc.property(\n          fc.array(videoIdArbitrary, { minLength: 2, maxLength: 5 }),\n          frameIndexArbitrary,\n          async (videoIds, frameIndex) => {\n            // Mock backend responses for each video\n            for (const videoId of videoIds) {\n              const mockFrameData: FrameData = {\n                videoId,\n                frameIndex,\n                timestamp: frameIndex * (1000 / 30),\n                originalFrame: `base64data_${videoId}`,\n                meshData: {\n                  keypoints: [],\n                  skeleton: { connections: [] }\n                }\n              };\n\n              (global.fetch as any).mockResolvedValueOnce({\n                ok: true,\n                headers: new Map([['content-encoding', 'identity']]),\n                json: async () => mockFrameData\n              });\n            }\n\n            // Get frame data for all videos\n            const frameDataList = await Promise.all(\n              videoIds.map(videoId =>\n                frameDataService.getFrame(videoId, frameIndex, {\n                  includeOriginal: true,\n                  includeMesh: true\n                })\n              )\n            );\n\n            // All frames should correspond to same frameIndex\n            for (const frameData of frameDataList) {\n              expect(frameData.frameIndex).toBe(frameIndex);\n            }\n          }\n        ),\n        { numRuns: 30 }\n      );\n    });\n\n    it('should reject frames with mismatched frameIndex', () => {\n      fc.assert(\n        fc.property(videoIdArbitrary, frameIndexArbitrary, async (videoId, frameIndex) => {\n          // Mock backend response with wrong frameIndex\n          const mockFrameData: FrameData = {\n            videoId,\n            frameIndex: frameIndex + 1, // Wrong frame index\n            timestamp: (frameIndex + 1) * (1000 / 30),\n            originalFrame: 'base64data',\n            meshData: {\n              keypoints: [],\n              skeleton: { connections: [] }\n            }\n          };\n\n          (global.fetch as any).mockResolvedValueOnce({\n            ok: true,\n            headers: new Map([['content-encoding', 'identity']]),\n            json: async () => mockFrameData\n          });\n\n          // Should throw error\n          await expect(\n            frameDataService.getFrame(videoId, frameIndex, {\n              includeOriginal: true,\n              includeMesh: true\n            })\n          ).rejects.toThrow('Frame index mismatch');\n        }),\n        { numRuns: 30 }\n      );\n    });\n\n    it('should maintain correspondence when filtering frame data', () => {\n      fc.assert(\n        fc.property(videoIdArbitrary, frameIndexArbitrary, async (videoId, frameIndex) => {\n          const mockFrameData: FrameData = {\n            videoId,\n            frameIndex,\n            timestamp: frameIndex * (1000 / 30),\n            originalFrame: 'base64data',\n            overlayFrame: 'base64overlay',\n            meshData: {\n              keypoints: [],\n              skeleton: { connections: [] }\n            }\n          };\n\n          (global.fetch as any).mockResolvedValueOnce({\n            ok: true,\n            headers: new Map([['content-encoding', 'identity']]),\n            json: async () => mockFrameData\n          });\n\n          // Get only original frame\n          const originalOnly = await frameDataService.getFrame(videoId, frameIndex, {\n            includeOriginal: true,\n            includeOverlay: false,\n            includeMesh: false\n          });\n\n          expect(originalOnly.frameIndex).toBe(frameIndex);\n          expect(originalOnly.originalFrame).toBeDefined();\n          expect(originalOnly.overlayFrame).toBeUndefined();\n          expect(originalOnly.meshData).toBeUndefined();\n        }),\n        { numRuns: 30 }\n      );\n    });\n\n    it('should maintain correspondence in local cache', () => {\n      fc.assert(\n        fc.property(videoIdArbitrary, frameIndexArbitrary, async (videoId, frameIndex) => {\n          const mockFrameData: FrameData = {\n            videoId,\n            frameIndex,\n            timestamp: frameIndex * (1000 / 30),\n            originalFrame: 'base64data',\n            meshData: {\n              keypoints: [],\n              skeleton: { connections: [] }\n            }\n          };\n\n          (global.fetch as any).mockResolvedValueOnce({\n            ok: true,\n            headers: new Map([['content-encoding', 'identity']]),\n            json: async () => mockFrameData\n          });\n\n          // First fetch\n          const frameData1 = await frameDataService.getFrame(videoId, frameIndex, {\n            includeOriginal: true,\n            includeMesh: true\n          });\n\n          // Second fetch (from cache)\n          const frameData2 = await frameDataService.getFrame(videoId, frameIndex, {\n            includeOriginal: true,\n            includeMesh: true\n          });\n\n          // Both should have same frameIndex\n          expect(frameData1.frameIndex).toBe(frameIndex);\n          expect(frameData2.frameIndex).toBe(frameIndex);\n          expect(frameData1.frameIndex).toBe(frameData2.frameIndex);\n        }),\n        { numRuns: 30 }\n      );\n    });\n  });\n});\n