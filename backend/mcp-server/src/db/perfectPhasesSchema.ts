import { Db } from 'mongodb';\n\nexport async function createPerfectPhasesSchema(db: Db): Promise<void> {\n  try {\n    // Create perfect_phases collection if it doesn't exist\n    const collections = await db.listCollections().toArray();\n    const collectionNames = collections.map((c) => c.name);\n\n    if (!collectionNames.includes('perfect_phases')) {\n      await db.createCollection('perfect_phases');\n    }\n\n    const collection = db.collection('perfect_phases');\n\n    // Create indexes for efficient querying\n    await collection.createIndex({ trickName: 1 });\n    await collection.createIndex({ phaseName: 1 });\n    await collection.createIndex({ stance: 1 });\n    await collection.createIndex({ dateCreated: -1 });\n    await collection.createIndex({\n      trickName: 1,\n      phaseName: 1,\n      stance: 1,\n    });\n\n    console.log('Perfect phases schema created successfully');\n  } catch (error) {\n    console.error('Failed to create perfect phases schema:', error);\n    throw error;\n  }\n}\n\nexport interface PerfectPhaseDocument {\n  _id?: any;\n  trickName: string;\n  phaseName: string;\n  stance: string;\n  frames: {\n    frameNumber: number;\n    imageRaw: string;\n    imageMeshOverlay: string;\n    poseData: {\n      frameNumber: number;\n      timestamp: number;\n      joints: Array<{\n        name: string;\n        x: number;\n        y: number;\n        z: number;\n        confidence: number;\n      }>;\n      angles: Array<{\n        name: string;\n        angle: number;\n        confidence: number;\n      }>;\n      overallConfidence: number;\n      detectionSignals: Array<{\n        name: string;\n        value: number;\n        threshold: number;\n        status: 'good' | 'warning' | 'critical';\n      }>;\n    };\n  }[];\n  dataQuality: {\n    averageConfidence: number;\n    highConfidenceFrames: number;\n    mediumConfidenceFrames: number;\n    lowConfidenceFrames: number;\n    qualityIndicator: 'excellent' | 'good' | 'fair' | 'poor';\n  };\n  dateCreated: Date;\n  dateModified: Date;\n}\n\nexport const PERFECT_PHASES_VALIDATION = {\n  $jsonSchema: {\n    bsonType: 'object',\n    required: [\n      'trickName',\n      'phaseName',\n      'stance',\n      'frames',\n      'dataQuality',\n      'dateCreated',\n    ],\n    properties: {\n      _id: { bsonType: 'objectId' },\n      trickName: {\n        bsonType: 'string',\n        description: 'Name of the trick (e.g., Backside 360)',\n      },\n      phaseName: {\n        bsonType: 'string',\n        enum: [\n          'setupCarve',\n          'windUp',\n          'snap',\n          'takeoff',\n          'air',\n          'landing',\n        ],\n        description: 'Phase of the trick',\n      },\n      stance: {\n        bsonType: 'string',\n        enum: ['regular', 'goofy'],\n        description: 'Rider stance',\n      },\n      frames: {\n        bsonType: 'array',\n        description: 'Array of frames in this phase',\n        items: {\n          bsonType: 'object',\n          required: [\n            'frameNumber',\n            'imageRaw',\n            'imageMeshOverlay',\n            'poseData',\n          ],\n          properties: {\n            frameNumber: { bsonType: 'int' },\n            imageRaw: { bsonType: 'string' },\n            imageMeshOverlay: { bsonType: 'string' },\n            poseData: {\n              bsonType: 'object',\n              required: [\n                'frameNumber',\n                'timestamp',\n                'joints',\n                'overallConfidence',\n              ],\n              properties: {\n                frameNumber: { bsonType: 'int' },\n                timestamp: { bsonType: 'double' },\n                joints: {\n                  bsonType: 'array',\n                  items: {\n                    bsonType: 'object',\n                    required: ['name', 'x', 'y', 'z', 'confidence'],\n                    properties: {\n                      name: { bsonType: 'string' },\n                      x: { bsonType: 'double' },\n                      y: { bsonType: 'double' },\n                      z: { bsonType: 'double' },\n                      confidence: { bsonType: 'double' },\n                    },\n                  },\n                },\n                angles: {\n                  bsonType: 'array',\n                  items: {\n                    bsonType: 'object',\n                    properties: {\n                      name: { bsonType: 'string' },\n                      angle: { bsonType: 'double' },\n                      confidence: { bsonType: 'double' },\n                    },\n                  },\n                },\n                overallConfidence: { bsonType: 'double' },\n                detectionSignals: {\n                  bsonType: 'array',\n                  items: {\n                    bsonType: 'object',\n                    properties: {\n                      name: { bsonType: 'string' },\n                      value: { bsonType: 'double' },\n                      threshold: { bsonType: 'double' },\n                      status: {\n                        bsonType: 'string',\n                        enum: ['good', 'warning', 'critical'],\n                      },\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n      dataQuality: {\n        bsonType: 'object',\n        required: [\n          'averageConfidence',\n          'highConfidenceFrames',\n          'mediumConfidenceFrames',\n          'lowConfidenceFrames',\n          'qualityIndicator',\n        ],\n        properties: {\n          averageConfidence: { bsonType: 'double' },\n          highConfidenceFrames: { bsonType: 'int' },\n          mediumConfidenceFrames: { bsonType: 'int' },\n          lowConfidenceFrames: { bsonType: 'int' },\n          qualityIndicator: {\n            bsonType: 'string',\n            enum: ['excellent', 'good', 'fair', 'poor'],\n          },\n        },\n      },\n      dateCreated: { bsonType: 'date' },\n      dateModified: { bsonType: 'date' },\n    },\n  },\n};\n